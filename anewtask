import React, { useState, useEffect } from "react";
import "./documentUpload.scss";
import { useDispatch, useSelector } from "react-redux";
import Modal from "../modals/tipsModal/tips-modal";
import PopupModel from "../../../../../shared/components/popup-model/popup-model";
import Carousel from "../carousel/carousel";
import banner1 from "../images-du/illustration-03@3x.png";
import banner2 from "../images-du/illustration-06@3x.png";
import banner3 from "../images-du/illustration-05@3x.png";
import banner4 from "../images-du/illustration-02@3x.png";
import banner5 from "../images-du/illustration-01@3x.png";
import banner6 from "../images-du/illustration-04@3x.png";
import ImagePreviewModal from "../modals/imagePreviewModal/image-preview-modal";
import {  postDocuments,} from "../../../services/preApprovalPostServices";
import AlertModel from "../../../alertModal/alert-modal";
import { dispatchLoader } from "../../../../../services/common-service";
import { StoreModel } from "../../../../../utils/model/common-model";
import { stagesAction } from "../../../../../utils/store/stages-slice";
import { CONSTANTS } from "../../../../../utils/common/constants";

const DocumentUpload: React.FC<any> = ({
  setShowIncomeProof,
  showQRCodePage,
  setShowQRCodePage,
  channel_reference,
  setHKIDVersion,
  setShowContinueBtn,
}) => {
  const dispatch = useDispatch();
  const footeContent =
    "File format should be in JPG or PNG. The individual file size must not exceed 5MB. Click";
  const copyRights = "© Standard Chartered Bank (HK) Limited";
  const images: any = [
    {
      banner: banner1,
      step: "Step 1",
      stepText: "Scan the QR code with a mobile phone",
    },
    {
      banner: banner2,
      step: "Step 2",
      stepText:
        "Remove card holder and place it on a flat surface under adequate lighting",
    },
    {
      banner: banner3,
      step: "Step 3",
      stepText:
        "Capture ID from above and align the edges with the rectangular frames",
    },
    {
      banner: banner4,
      step: "Step 4",
      stepText: "Tilt mobile phone about 30-degree and capture from aside",
    },
    {
      banner: banner5,
      step: "Step 5",
      stepText:
        "Remove accessories and face mask and place full face in the circular frame and blink once as instructed",
    },
    {
      banner: banner6,
      step: "Step 6",
      stepText: "Return to desktop browser and click “Submit” to continue",
    },
  ];
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [imagePreview, setImagePreview] = useState(false);
  const [imgeURL, setImageURL] = useState("");
  const [name, setName] = useState("");
  const [files, setFiles] = useState<any>([]);
  const [openSuccessModal, setOpenSuccessModal] = useState(false);
  const [validImageSizeModel, setValidImageSizeModel] = useState(false);
  const [continueBtnVisiblity, setContinueBtnVisiblity] = useState(false);
  const stageSelector = useSelector(
    (state: StoreModel) => state.stages.stages[0].stageInfo
  );
  const docName = useSelector((state: any) => {
    return state?.preApproval?.documentZoloCheckRes?.data?.documents[0]
    ?.documentName;
  });
  const documentCount = useSelector((state: any) => state.stages.dynamicDocumentsUpload.documentCount);
  const fileSectionData = useSelector((state: any) => state.stages.dynamicDocumentsUpload.fileSectionData);
  const imgUrl = useSelector((state: any) => {
    return state?.preApproval?.imgPrevURL;
  });

  useEffect(() => {
    dispatch(dispatchLoader(false));

    var isMobile = false;
    if (
      /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
        navigator.userAgent
      )
    ) {
      isMobile = true;
    }
    console.log(isMobile);
    
    
  }, []);

  const closeFileUpload = () => {
    setShowIncomeProof("");
    setShowQRCodePage(false);
    setHKIDVersion("");
    setShowContinueBtn(false);
  };

  const closeFileUploadBack = () => {
    dispatch(stagesAction.updatefileSectionData([]))
  };

  const handleUploadFile = async (e: any) => {
    const filename = e.target.files[0].name;
    const filesize = `${(e.target.files[0].size / (1024 * 1012)).toFixed(2)}MB`;
    const file = e.target.files[0];
    const maxSize = 5 * 1024 * 1024;

    if (file.size > maxSize) {
      setValidImageSizeModel(true);
      return;
    }
    try {
      await dispatch(dispatchLoader(true));
      const response = await postDocuments(
        channel_reference,
        e.target.files[0]
      );
      const tempData = {
        file: file,
        filename: filename,
        filesize: filesize,
        ...response.data,
      };
      if (response.statusText === "Accepted") {
         let newFiles = files;
         newFiles.push(tempData)
          setFiles(newFiles)     
      }
      await dispatch(dispatchLoader(false));
    } catch (err) {
      console.log("err:", err);
    }
  };
  const okBtnClick = (e: any) => {
    const { title } = e.target;
    let filesValue= stageSelector.applicant_documents[0].document_list
    let filesData: any = JSON.parse(JSON.stringify(filesValue))
    for (let i in filesData) {
      if (filesData[i].document_category === fileSectionData.document_category) {
        filesData[i].document_options[0].document_types[0].uploaded_documents = files
      }
    }
    let stageData = JSON.parse(JSON.stringify(stageSelector));
    stageData.applicant_documents[0].document_list = filesData;
    dispatch(
      stagesAction.getStage({
        id: CONSTANTS.STAGE_NAMES.DOC_3,
        formConfig: stageData,
      })
    );
    setContinueBtnVisiblity(true);
    dispatch(stagesAction.updateDocumentCount(documentCount + 1));
    dispatch(stagesAction.updatefileSectionData([]))
    setShowIncomeProof("");
    dispatch(stagesAction.updatechangechangeIconIncomeProof(false));
    dispatch(stagesAction.updateSuccess(true))
    setHKIDVersion("");
    setShowContinueBtn(false);
  };

  const handleDelete = (docId: any) => {
    const updateFiles = files.filter((file: any)=>file.docId !== docId);
    setFiles(updateFiles)
  };
  const handleRefresh = (fileID: any, index: any) => { };

  const callModal = () => {
    setIsModalOpen(true);
  };
  const openImagePreview = (img: any, name: any) => {
    setImageURL(img);
    setName(name);
    setImagePreview(true);
  };

  const successModalClose = () => {
    setOpenSuccessModal(false);
  };

  const modelClose = () => {
    setValidImageSizeModel(false);
  };
  return (
    <>
      <div className={"document-view"}>
        {
          <PopupModel displayPopup={openSuccessModal}>
            <AlertModel alertType="Success" goBack={successModalClose} />
          </PopupModel>
        }

        {validImageSizeModel && (
          <PopupModel displayPopup={validImageSizeModel}>
            <AlertModel alertType={"invalideimagesize"} goBack={modelClose} />
          </PopupModel>
        )}
        {imagePreview && (
          <ImagePreviewModal
            imgeURL={imgeURL}
            name={name}
            imagePreview={imagePreview}
            setImagePreview={setImagePreview}
          />
        )}
        {!showQRCodePage && (
          <>
            <Modal isModalOpen={isModalOpen} setIsModalOpen={setIsModalOpen} />
            <div className="container">
              <div className="uploadHkDocument">
                <p className="doc-close" onClick={closeFileUpload}>
                  <span className="doc-close-btn"></span>
                  CLOSE
                </p>
                <p className="hk-proof-name">{fileSectionData.document_category}</p>
              </div>
              {files?.map((item: any, index: any) => {
                return (
                  <div className="upload-btn1" key={index}>
                    <div className="thumbnail-img-container">
                      <a>
                        <img
                          data-testid="image-preview-id"
                          src={URL.createObjectURL(item.file)}
                          alt={item.filename}
                          onClick={() =>
                            openImagePreview(
                              URL.createObjectURL(item.file),
                              item.filename
                            )
                          }
                        ></img>
                      </a>
                    </div>
                    <div className="container-image">
                      <div className="uploading-doc-name">
                        <span className="span-file-name">{item.filename}</span>
                        <div className="progress-text-icon"></div>
                        {item.documentStatus === "UPLOADED" && (
                          <div
                            data-testid="delete-btn"
                            role="button"
                            className="trash-icon"
                            onClick={() => {
                              handleDelete(item.docId);
                            }}
                          ></div>
                         )} 
                        {item.documentStatus === "Upload failed" && (
                          <div
                            data-testid="refresh-btn"
                            className="retry-icon"
                            onClick={() => {
                              handleRefresh(item.docId, index);
                            }}
                          ></div>
                        )}
                      </div>
                      <div
                        className={
                          item.documentStatus === "UPLOADED"
                            ? "uploaded"
                            : "retry-uploaded"
                        }
                      ></div>
                      <div
                        className={
                          item.documentStatus === "UPLOADED"
                            ? "tick-mark"
                            : "no-tick-mark"
                        }
                      >
                        {item.documentStatus === "UPLOADED"
                          ? `${"Upload completed"} !`
                          : `${item.documentStatus} Retry?`}
                      </div>
                      <div className="fileSizeDetails">
                        <span>{item.filesize}</span>
                      </div>
                    </div>
                  </div>
                );
              })}
              <div className="upload-btn-section">
                <input
                  className="upload-input-file"
                  id="file-upload"
                  type="file"
                  accept=".jpg, .png"
                  onChange={(e) => handleUploadFile(e)}
                  multiple
                />
                <label htmlFor="file-upload" className="upload-btn">
                  <span className="upload-img"></span>
                  Upload
                </label>
              </div>
              <div className="document-footer">
                <div className="footer-banner">
                  <div className="footer-content">
                    <p className="sec-2">
                      {" "}
                      {footeContent}
                      <span className="tipsLink" onClick={callModal}>
                        {" "}
                        here{" "}
                      </span>{" "}
                      on tips for uploading
                    </p>
                  </div>
                  <span className="images"></span>
                </div>
              </div>
              <div className="hk-copy-rights">
                <p>{copyRights}</p>
              </div>
              <div className="footer footer-set">
                {" "}
                {
                  <div title="back-btn-upload-doc1" className="back" onClick={closeFileUploadBack}>
                    <span className="arrow"></span> Back
                  </div>
                }
                <button
                  role="button"
                  title={fileSectionData.document_category}
                  type="submit"
                  style={{border: "20px"}}
                  className={
                    files?.length === 0
                    ? `continue form-invalid`
                    : `continue form-valid`
                  }
                  onClick={(e) => okBtnClick(e)}
                  disabled={files?.length === 0}
                  >
                  Continue
                </button>
              </div>
            </div>
          </>
        )}
      </div>

    </>
  );
};

export default DocumentUpload;



import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import "@testing-library/jest-dom";
import { Provider } from "react-redux";
import configureStore from "redux-mock-store";
import DocumentUpload from "../DocumentUpload"; // Adjust path as needed
import { postDocuments } from "../../../services/preApprovalPostServices";

jest.mock("../../../services/preApprovalPostServices", () => ({
  postDocuments: jest.fn(),
}));

// Mock the redux store
const mockStore = configureStore([]);
const store = mockStore({
  stages: {
    stages: [{ stageInfo: { applicant_documents: [{ document_list: [] }] } }],
    dynamicDocumentsUpload: { documentCount: 0, fileSectionData: { document_category: "ID Proof" } },
  },
  preApproval: {
    documentZoloCheckRes: { data: { documents: [{ documentName: "Test Document" }] } },
    imgPrevURL: "test-image-url",
  },
});

// Mock dispatch function
const mockDispatch = jest.fn();
jest.mock("react-redux", () => ({
  useDispatch: () => mockDispatch,
  useSelector: (callback) => callback(store.getState()),
}));

describe("DocumentUpload Component", () => {
  const defaultProps = {
    setShowIncomeProof: jest.fn(),
    showQRCodePage: false,
    setShowQRCodePage: jest.fn(),
    channel_reference: "12345",
    setHKIDVersion: jest.fn(),
    setShowContinueBtn: jest.fn(),
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  test("should render the component correctly", () => {
    render(
      <Provider store={store}>
        <DocumentUpload {...defaultProps} />
      </Provider>
    );

    expect(screen.getByText("CLOSE")).toBeInTheDocument();
    expect(screen.getByText("ID Proof")).toBeInTheDocument();
    expect(screen.getByText("Upload")).toBeInTheDocument();
    expect(screen.getByRole("button", { name: "Continue" })).toBeDisabled();
  });

  test("should open and close modal", () => {
    render(
      <Provider store={store}>
        <DocumentUpload {...defaultProps} />
      </Provider>
    );

    fireEvent.click(screen.getByText("here"));
    expect(screen.getByTestId("modal")).toBeInTheDocument();

    fireEvent.click(screen.getByTestId("close-modal-btn"));
    expect(screen.queryByTestId("modal")).not.toBeInTheDocument();
  });

  test("should handle file upload successfully", async () => {
    const file = new File(["dummy content"], "test.jpg", { type: "image/jpeg" });

    (postDocuments as jest.Mock).mockResolvedValue({
      statusText: "Accepted",
      data: { documentStatus: "UPLOADED" },
    });

    render(
      <Provider store={store}>
        <DocumentUpload {...defaultProps} />
      </Provider>
    );

    const input = screen.getByLabelText("Upload");
    fireEvent.change(input, { target: { files: [file] } });

    await waitFor(() => expect(postDocuments).toHaveBeenCalledTimes(1));
    expect(mockDispatch).toHaveBeenCalled();
  });

  test("should prevent file upload if file size exceeds limit", async () => {
    const file = new File(["a".repeat(6 * 1024 * 1024)], "large-file.jpg", { type: "image/jpeg" });

    render(
      <Provider store={store}>
        <DocumentUpload {...defaultProps} />
      </Provider>
    );

    const input = screen.getByLabelText("Upload");
    fireEvent.change(input, { target: { files: [file] } });

    await waitFor(() => {
      expect(screen.getByText("Invalid image size")).toBeInTheDocument();
    });
  });

  test("should handle delete file functionality", async () => {
    (postDocuments as jest.Mock).mockResolvedValue({
      statusText: "Accepted",
      data: { documentStatus: "UPLOADED", docId: "123" },
    });

    render(
      <Provider store={store}>
        <DocumentUpload {...defaultProps} />
      </Provider>
    );

    const file = new File(["dummy content"], "test.jpg", { type: "image/jpeg" });
    const input = screen.getByLabelText("Upload");
    fireEvent.change(input, { target: { files: [file] } });

    await waitFor(() => screen.getByTestId("delete-btn"));
    fireEvent.click(screen.getByTestId("delete-btn"));

    expect(screen.queryByTestId("image-preview-id")).not.toBeInTheDocument();
  });

  test("should open image preview modal", async () => {
    render(
      <Provider store={store}>
        <DocumentUpload {...defaultProps} />
      </Provider>
    );

    const file = new File(["dummy content"], "test.jpg", { type: "image/jpeg" });
    const input = screen.getByLabelText("Upload");
    fireEvent.change(input, { target: { files: [file] } });

    await waitFor(() => screen.getByTestId("image-preview-id"));
    fireEvent.click(screen.getByTestId("image-preview-id"));

    expect(screen.getByTestId("image-preview-modal")).toBeInTheDocument();
  });

  test("should close file upload section when 'Close' is clicked", () => {
    render(
      <Provider store={store}>
        <DocumentUpload {...defaultProps} />
      </Provider>
    );

    fireEvent.click(screen.getByText("CLOSE"));
    expect(defaultProps.setShowIncomeProof).toHaveBeenCalledWith("");
    expect(defaultProps.setShowQRCodePage).toHaveBeenCalledWith(false);
    expect(defaultProps.setHKIDVersion).toHaveBeenCalledWith("");
    expect(defaultProps.setShowContinueBtn).toHaveBeenCalledWith(false);
  });

  test("should trigger continue button click", async () => {
    (postDocuments as jest.Mock).mockResolvedValue({
      statusText: "Accepted",
      data: { documentStatus: "UPLOADED" },
    });

    render(
      <Provider store={store}>
        <DocumentUpload {...defaultProps} />
      </Provider>
    );

    const file = new File(["dummy content"], "test.jpg", { type: "image/jpeg" });
    const input = screen.getByLabelText("Upload");
    fireEvent.change(input, { target: { files: [file] } });

    await waitFor(() => screen.getByRole("button", { name: "Continue" }));

    fireEvent.click(screen.getByRole("button", { name: "Continue" }));
    expect(mockDispatch).toHaveBeenCalled();
  });

  test("should trigger back button click", () => {
    render(
      <Provider store={store}>
        <DocumentUpload {...defaultProps} />
      </Provider>
    );

    fireEvent.click(screen.getByTitle("back-btn-upload-doc1"));
    expect(mockDispatch).toHaveBeenCalled();
  });
});
