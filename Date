import React from 'react';
import SignModel from './sign-model';
import { Provider } from 'react-redux';
import { cleanup, fireEvent, render, screen, waitFor } from '@testing-library/react';
import { store } from './../../../utils/store/store';
import axios from 'axios';
import { stagesAction } from '../../../utils/store/stages-slice';
import { signatureSubmit } from '../../../services/common-service';

jest.mock('react-redux', () => ({
  ...jest.requireActual('react-redux'),
  useSelector: jest.fn(),
  useDispatch: () => jest.fn(),
}));

jest.mock('../../../services/common-service', () => ({
  signatureSubmit: jest.fn(),
}));

const mockDispatch = jest.fn();
jest.mock('react-redux', () => ({
  ...jest.requireActual('react-redux'),
  useDispatch: () => mockDispatch,
  useSelector: jest.fn(),
}));

const mockUseSelector = useSelector as jest.Mock;

const createPortalSetup = () => {
  const portalRoot = document.createElement('div');
  portalRoot.setAttribute('id', 'model-root');
  document.body.appendChild(portalRoot);
  return portalRoot;
};

describe('SignModel component', () => {
  const baseProps = {
    handlebuttonClick: jest.fn(),
    show: true,
    viewSignature: null,
    fieldName: 'signUser',
    setValue: jest.fn(),
    data: { maxLength: 160 },
    popupTitle: 'Test Title',
  };

  beforeEach(() => {
    createPortalSetup();
    mockDispatch.mockClear();
    (axios.post as jest.Mock).mockClear();
    mockUseSelector.mockImplementation((selector) =>
      selector({
        stages: {
          stages: [{
            stageInfo: {
              application: { channel_reference: 'test-ref' },
              applicants: {}
            }
          }],
          userInput: { applicants: {} }
        }
      })
    );
  });

  afterEach(() => {
    const portalRoot = document.getElementById('model-root');
    if (portalRoot) document.body.removeChild(portalRoot);
    cleanup();
  });

  test('renders signature interface for signUser field', () => {
    render(
      <Provider store={store}>
        <SignModel {...baseProps} />
      </Provider>
    );

    expect(screen.getByText('Signature')).toBeInTheDocument();
    expect(screen.getByText('Sign in the box below')).toBeInTheDocument();
    expect(screen.getByText('Reset')).toBeInTheDocument();
  });

  test('renders textarea interface for purposeOther field', () => {
    render(
      <Provider store={store}>
        <SignModel {...baseProps} fieldName="purposeOther" />
      </Provider>
    );

    expect(screen.getByText('Test Title')).toBeInTheDocument();
    expect(screen.getByText('Please provide details')).toBeInTheDocument();
    expect(screen.getByRole('textbox')).toBeInTheDocument();
  });

  test('handles textarea input and validation', async () => {
    render(
      <Provider store={store}>
        <SignModel {...baseProps} fieldName="purposeOther" />
      </Provider>
    );

    const textarea = screen.getByRole('textbox');
    fireEvent.change(textarea, { target: { value: 'a'.repeat(161) } });
    expect(screen.getByText('Characters limit exceeded')).toBeInTheDocument();
    expect(screen.getByText('161/160')).toBeInTheDocument();

    fireEvent.change(textarea, { target: { value: 'Test@' } });
    expect(screen.getByText('Special Characters not allowed')).toBeInTheDocument();
  });

  test('handles signature confirmation', async () => {
    const { container } = render(
      <Provider store={store}>
        <SignModel {...baseProps} />
      </Provider>
    );

    // Mock signature data
    const mockSignature = { array: [1,2,3], jpeg: 'test-jpeg' };
    const signaturePad = container.querySelector('.sign-previw');
    if (signaturePad) {
      fireEvent.mouseUp(signaturePad);
    }

    // Simulate signature end
    await waitFor(() => {
      const confirmBtn = screen.getByText('Confirm signature');
      fireEvent.click(confirmBtn);
    });

    expect(mockDispatch).toHaveBeenCalledWith(stagesAction.setSignatureDocument(expect.any(Array)));
    expect(signatureSubmit).toHaveBeenCalled();
  });

  test('handles text confirmation', () => {
    render(
      <Provider store={store}>
        <SignModel {...baseProps} fieldName="purposeOther" />
      </Provider>
    );

    const textarea = screen.getByRole('textbox');
    fireEvent.change(textarea, { target: { value: 'Valid input' } });
    fireEvent.click(screen.getByText('Confirm'));

    expect(baseProps.setValue).toHaveBeenCalledWith('Valid input');
    expect(baseProps.handlebuttonClick).toHaveBeenCalledWith(false);
  });

  test('disables buttons when invalid', () => {
    render(
      <Provider store={store}>
        <SignModel {...baseProps} />
      </Provider>
    );

    expect(screen.getByText('Confirm signature')).toBeDisabled();
  });

  test('handles signature reset', () => {
    render(
      <Provider store={store}>
        <SignModel {...baseProps} viewSignature="existing-sig" />
      </Provider>
    );

    fireEvent.click(screen.getByText('Reset'));
    expect(screen.getByText('Confirm signature')).toBeDisabled();
  });

  test('initializes with existing signature', () => {
    render(
      <Provider store={store}>
        <SignModel {...baseProps} viewSignature="existing-sig" />
      </Provider>
    );

    expect(screen.getByText('Confirm signature')).toBeEnabled();
  });

  test('handles mobile rotation message', () => {
    render(
      <Provider store={store}>
        <SignModel {...baseProps} />
      </Provider>
    );

    expect(screen.getByText('Rotate your phone for a larger space to sign in')).toBeInTheDocument();
  });
});
