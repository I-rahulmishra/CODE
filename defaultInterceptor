yTo cover the uncovered lines in the provided code using Jest and React Testing Library (RTL), follow these steps:

Key Points from the Image:

1. Default Interceptor Logic:

Includes dynamic headers based on store state.

Handles specific logic for scClientContextHeaders and abortController.



2. Axios Request Interceptor:

Appends headers to outgoing requests.

Uses abortController to handle request cancellation.



3. Dynamic Conditions:

Headers depend on stages from store.getState().



4. Axios Response Interceptor:

Captures responses and errors.





---

Steps to Write Jest Tests

1. Mock Axios:

Use Jest to mock the axios library:

jest.mock('axios');
import axios from 'axios';

2. Mock Store:

Mock the store object to simulate store.getState():

const mockStore = {
  getState: jest.fn(() => ({
    auth: { sessionUuid: 'mockSessionId' },
    stages: [{ id: 1, stageId: 'mockStageId' }],
  })),
};

3. Test Default Interceptor:

Test the logic for setting headers in scClientContextHeaders:

import { injectStore, defaultInterceptor } from './yourFilePath';

describe('defaultInterceptor', () => {
  beforeEach(() => {
    injectStore(mockStore);
  });

  it('should set scClientContextHeaders correctly', () => {
    const lang = 'EN';
    const interceptor = defaultInterceptor(lang);

    expect(interceptor).toBeDefined();
    expect(interceptor.scClientContextHeaders.Channel).toBe('MOBILE');
    expect(interceptor.scClientContextHeaders.LoginType).toBe('PRE');
    expect(interceptor.scClientContextHeaders.Country).toBe('HK');
  });

  it('should handle stages correctly', () => {
    const stagesMock = [
      { id: 1, stageId: 'mockStageId' },
      { id: 2, stageId: 'anotherStageId' },
    ];
    mockStore.getState.mockReturnValue({ stages: stagesMock });

    const interceptor = defaultInterceptor(null);

    expect(interceptor).toBeDefined();
    expect(interceptor.headers['SC-CLIENT-CONTEXT']).toContain('mockStageId');
  });
});

4. Test Abort Controller:

Validate request cancellation:

it('should abort requests using abortController', () => {
  const abortController = new AbortController();
  abortController.abort();

  expect(abortController.signal.aborted).toBe(true);
});

5. Test Axios Interceptor Logic:

Ensure axios.interceptors.request.use sets the headers correctly:

it('should set axios headers correctly', () => {
  const requestConfig = { url: '/test', headers: {} };
  axios.interceptors.request.use.mockImplementation((callback) => callback(requestConfig));

  defaultInterceptor('EN');

  expect(requestConfig.headers['Content-Type']).toBe('application/json');
  expect(requestConfig.headers['SC-CLIENT-CONTEXT']).toBeDefined();
});

6. Test Axios Response Handling:

Validate axios.interceptors.response.use:

it('should handle axios responses correctly', async () => {
  const responseMock = { data: 'mockData' };
  axios.interceptors.response.use.mockImplementation((res) => res);

  const response = await axios.get('/test');
  expect(response.data).toBe('mockData');
});


---

Run Tests

Save your tests in a file (e.g., yourFile.test.js) and run them:

npx jest yourFile.test.js


---

Improve Coverage

Include edge cases (e.g., stages is empty).

Simulate errors in Axios requests.


Would you like a detailed explanation of any part?

