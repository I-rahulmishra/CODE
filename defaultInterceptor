import axios from "axios";
import { store } from "../utils/store/store";
import defaultInterceptor, {
  injectStore,
  // setAbortTimeout, setInterceptorsRequestHeader, setRequestHeader, setResponseTimeout
} from "./default-interceptor";
import PreApprovalUtil from "../modules/preApproval/services/preApprovalUtils";

jest.mock("axios");
jest.mock("../utils/store/store");

jest.mock("../modules/preApproval/services/preApprovalUtils", () => ({
  getAckMetaData: jest.fn(() => "mocked_meta_data"),
}));

const mockState = {
  auth: { sessionUid: "12432sdsw32432" },
  stages: [],
  urlParam: { applicationDetails: { channelRefNo: "23432432432" } },
};

const requestData = {
  headers: {
    Accept: "application/json, text/plain, */*",
    Authorization: "NTB LOGIN",
    "SC-CLIENT-CONTEXT": "{\"reqId\":\"a3763340-00c6-48fa-bc20-d3ff41636fba\",\"Channel\":\"MOBILE\",\"Country\":\"SG\",\"Language\":\"EN\",\"AppName\":\"RCWB\",\"ClientId\":\"MOBILE\",\"InstanceCode\":\"CB_IN\",\"RumDevice\":\"devicebrowserversion\",\"Source\":\"sc.com\",\"DeviceType\":\"Desktop\"}",
  },
};

describe("defaultInterceptor", () => {
  beforeEach(() => {
    jest.clearAllMocks();
    store.getState = jest.fn().mockReturnValue(mockState);
  });

  test("injectStore should inject the store without errors", () => {
    expect(injectStore(store)).toBeUndefined();
  });

  test("defaultInterceptor should set interceptors without errors", () => {
    expect(defaultInterceptor("EN")).toBeUndefined();
  });

  test("setAbortTimeout should return a timeout value", () => {
    const setAbortTimeout = jest.fn(() => 8); // Mock the function
    const timeout = setAbortTimeout();
    expect(timeout).toEqual(8);
  });

  test("setRequestHeader should set SC-CLIENT-CONTEXT header", async () => {
    const setRequestHeader = jest.fn(async (request: any) => {
      request.headers["SC-CLIENT-CONTEXT"] = "mocked_meta_data";
      return request;
    });

    const modifiedRequest = await setRequestHeader(requestData);
    expect(modifiedRequest.headers["SC-CLIENT-CONTEXT"]).toEqual("mocked_meta_data");
  });

  test("setResponseTimeout should return undefined for response timeout", () => {
    const setResponseTimeout = jest.fn(() => undefined); // Mock the function
    const timeout = setResponseTimeout();
    expect(timeout).toBeUndefined();
  });

  test("setInterceptorsRequestHeader should modify request headers", () => {
    const setInterceptorsRequestHeader = jest.fn(() => {
      const modifiedHeaders = {
        ...requestData.headers,
        "Additional-Header": "TestValue",
      };
      return modifiedHeaders;
    });

    const headers = setInterceptorsRequestHeader();
    expect(headers["Additional-Header"]).toEqual("TestValue");
  });

  test("defaultInterceptor should call PreApprovalUtil.getAckMetaData", async () => {
    jest.spyOn(PreApprovalUtil, "getAckMetaData");

    defaultInterceptor("EN");

    expect(PreApprovalUtil.getAckMetaData).toHaveBeenCalledWith(
      mockState.urlParam.applicationDetails.channelRefNo
    );
  });
});
