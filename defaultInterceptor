import axios from "axios";
import PreApprovalUtil from "../modules/preApproval/services/preApprovalUtils";
import submitService from "../services/submit-service";
import { CONSTANTS } from "../utils/common/constants";

let store: any;

export const injectStore = (_store: any) => {
  store = _store;
};

const defaultInterceptor = (lang: string | null) => {
  console.log('store'+JSON.stringify(store));
  let scClientContextHeaders: any = {
      Channel: "MOBILE",
      loginType: "PRE",
      Country: "HK",
      Language: "EN",
      AppName: "RCWB",
      ClientId: "MOBILE",
      InstanceCode: "CB_HK",
      RumDevice: "devicebrowserversion",
      Source: "sc.com",
      DeviceType: "MOBILE",
      subChannelCode: "",    
      sessionUID: store.getState().auth.sessionUid,
      BrowserAgent: "DESKTOP-BROWSER",
      IPAddress: ""
  };

  let abortController = new AbortController();
  const timeout = setTimeout(() => {
    abortController.abort();
  }, 180000);

  axios?.interceptors.request.use(
    async (request) => {
      let currentEndpoint: any = request.url && request.url.split("/");
      let uUid = submitService.generateUUID;
      let header: any = {
        "Content-Type": "application/json;charset=UTF-8",
      };

      scClientContextHeaders["reqId"] = uUid;
      let endPointURL = currentEndpoint[currentEndpoint.length - 1];
      if (store.getState().auth.sessionUid !== null) {
        const sessionUid = store.getState().auth.sessionUid;
        scClientContextHeaders["sessionUID"] = sessionUid;
      }
      header["Env"] = `${process.env.REACT_APP_RTOB_ENV}`;
      if (endPointURL === 'supportingaof') {
        header['responseType'] = 'arraybuffer';
      }
      
    let stages = JSON.parse(JSON.stringify(store.getState().stages));

      if(stages.stages && stages.stages.length > 0 && stages.stages[0].stageId && (stages.stages[0].stageId === CONSTANTS.STAGE_NAMES.AD_1 || stages.stages[0].stageId === CONSTANTS.STAGE_NAMES.ACD_1)) {
          request.headers["SC-CLIENT-CONTEXT"] = 
            await PreApprovalUtil.getAckMetaDataStageLevel(store.getState().urlParam.applicationDetails.channelRefNo)
      }
      else {
        request.headers["SC-CLIENT-CONTEXT"] = 
            PreApprovalUtil.getAckMetaData(store.getState().urlParam.applicationDetails.channelRefNo)
      }
      request.headers.set(header);

      return {
        ...request,
        signal: abortController.signal,
      };
    }
  );

  axios?.interceptors.response.use((res) => {
    clearTimeout(timeout);
    return res;
  });
};

export default defaultInterceptor;



import axios from "axios";
import MockAdapter from "axios-mock-adapter";
import defaultInterceptor, { injectStore } from "../path/to/defaultInterceptor";
import PreApprovalUtil from "../modules/preApproval/services/preApprovalUtils";
import submitService from "../services/submit-service";
import { CONSTANTS } from "../utils/common/constants";

jest.mock("../modules/preApproval/services/preApprovalUtils");
jest.mock("../services/submit-service");

describe("defaultInterceptor", () => {
  let mockStore: any;
  let mockAxios: MockAdapter;

  beforeEach(() => {
    // Mock store
    mockStore = {
      getState: jest.fn().mockReturnValue({
        auth: { sessionUid: "test-session-uid" },
        urlParam: { applicationDetails: { channelRefNo: "test-ref-no" } },
        stages: {
          stages: [
            {
              stageId: CONSTANTS.STAGE_NAMES.AD_1,
            },
          ],
        },
      }),
    };

    // Inject store
    injectStore(mockStore);

    // Mock axios
    mockAxios = new MockAdapter(axios);
  });

  afterEach(() => {
    jest.clearAllMocks();
    mockAxios.reset();
  });

  it("should set request headers correctly for AD_1 stage", async () => {
    const mockRequest = {
      url: "https://example.com/supportingaof",
      headers: new Map(),
    };

    // Mock PreApprovalUtil.getAckMetaDataStageLevel
    (PreApprovalUtil.getAckMetaDataStageLevel as jest.Mock).mockResolvedValue(
      "mocked-metadata"
    );

    const addInterceptor = () => defaultInterceptor("EN");
    addInterceptor();

    const onFulfilled = mockAxios.handlers.request[0][0];
    const modifiedRequest = await onFulfilled(mockRequest);

    expect(modifiedRequest.headers.get("SC-CLIENT-CONTEXT")).toEqual(
      "mocked-metadata"
    );
    expect(modifiedRequest.headers.get("responseType")).toBeUndefined();
    expect(modifiedRequest.signal).toBeDefined();
  });

  it("should set responseType to arraybuffer for supportingaof endpoint", async () => {
    const mockRequest = {
      url: "https://example.com/supportingaof",
      headers: new Map(),
    };

    const addInterceptor = () => defaultInterceptor("EN");
    addInterceptor();

    const onFulfilled = mockAxios.handlers.request[0][0];
    const modifiedRequest = await onFulfilled(mockRequest);

    expect(modifiedRequest.headers.get("responseType")).toEqual("arraybuffer");
  });

  it("should clear timeout on response", () => {
    const mockResponse = { data: { success: true } };

    const addInterceptor = () => defaultInterceptor("EN");
    addInterceptor();

    const onFulfilled = mockAxios.handlers.response[0][0];
    const modifiedResponse = onFulfilled(mockResponse);

    expect(modifiedResponse).toEqual(mockResponse);
  });

  it("should handle a missing session UID gracefully", async () => {
    mockStore.getState.mockReturnValueOnce({
      auth: { sessionUid: null },
      urlParam: { applicationDetails: { channelRefNo: "test-ref-no" } },
      stages: { stages: [] },
    });

    const mockRequest = {
      url: "https://example.com/endpoint",
      headers: new Map(),
    };

    const addInterceptor = () => defaultInterceptor("EN");
    addInterceptor();

    const onFulfilled = mockAxios.handlers.request[0][0];
    const modifiedRequest = await onFulfilled(mockRequest);

    expect(modifiedRequest.headers.get("SC-CLIENT-CONTEXT")).toBeUndefined();
  });

  it("should set SC-CLIENT-CONTEXT using PreApprovalUtil.getAckMetaData if stage is not AD_1 or ACD_1", async () => {
    mockStore.getState.mockReturnValueOnce({
      auth: { sessionUid: "test-session-uid" },
      urlParam: { applicationDetails: { channelRefNo: "test-ref-no" } },
      stages: {
        stages: [
          {
            stageId: "some-other-stage",
          },
        ],
      },
    });

    const mockRequest = {
      url: "https://example.com/endpoint",
      headers: new Map(),
    };

    (PreApprovalUtil.getAckMetaData as jest.Mock).mockReturnValue(
      "mocked-metadata"
    );

    const addInterceptor = () => defaultInterceptor("EN");
    addInterceptor();

    const onFulfilled = mockAxios.handlers.request[0][0];
    const modifiedRequest = await onFulfilled(mockRequest);

    expect(modifiedRequest.headers.get("SC-CLIENT-CONTEXT")).toEqual(
      "mocked-metadata"
    );
  });
});







import axios from "axios";
import MockAdapter from "axios-mock-adapter";
import defaultInterceptor, { injectStore } from "../path/to/defaultInterceptor";
import PreApprovalUtil from "../modules/preApproval/services/preApprovalUtils";
import submitService from "../services/submit-service";
import { CONSTANTS } from "../utils/common/constants";

jest.mock("../modules/preApproval/services/preApprovalUtils");
jest.mock("../services/submit-service");

describe("defaultInterceptor", () => {
  let mockStore: any;
  let mockAxios: MockAdapter;

  beforeEach(() => {
    // Mock store
    mockStore = {
      getState: jest.fn().mockReturnValue({
        auth: { sessionUid: "test-session-uid" },
        urlParam: { applicationDetails: { channelRefNo: "test-ref-no" } },
        stages: {
          stages: [
            {
              stageId: CONSTANTS.STAGE_NAMES.AD_1,
            },
          ],
        },
      }),
    };

    // Inject store
    injectStore(mockStore);

    // Mock axios
    mockAxios = new MockAdapter(axios);
  });

  afterEach(() => {
    jest.clearAllMocks();
    mockAxios.reset();
  });

  it("should set request headers correctly for AD_1 stage", async () => {
    // Configure mock response
    mockAxios.onAny().reply(200);

    const mockRequest = {
      url: "https://example.com/supportingaof",
      headers: {},
    };

    (PreApprovalUtil.getAckMetaDataStageLevel as jest.Mock).mockResolvedValue(
      "mocked-metadata"
    );

    defaultInterceptor("EN"); // Add interceptor

    const response = await axios.get(mockRequest.url);

    // Assertions
    expect(response.config.headers["SC-CLIENT-CONTEXT"]).toEqual(
      "mocked-metadata"
    );
  });

  it("should set responseType to arraybuffer for supportingaof endpoint", async () => {
    mockAxios.onAny().reply(200);

    defaultInterceptor("EN");

    const response = await axios.get("https://example.com/supportingaof");

    expect(response.config.headers["responseType"]).toEqual("arraybuffer");
  });

  it("should clear timeout on response", async () => {
    mockAxios.onAny().reply(200, { success: true });

    defaultInterceptor("EN");

    const response = await axios.get("https://example.com");

    expect(response.data.success).toBe(true);
  });
});



import axios, { InternalAxiosRequestConfig } from "axios";
import { store } from "../utils/store/store";
import { urlParamAction } from "../utils/store/urlparam-slice";
import defaultInterceptor, {   injectStore, 
  // setAbortTimeout, setInterceptorsRequestHeader, setRequestHeader, setResponseTimeout
 } from "./default-interceptor";
import { KFS_DOC_URL } from "../modules/preApproval/services/constants";
import { getData } from "../modules/preApproval/services/preApprovalServices";
import PreApprovalUtil from "../modules/preApproval/services/preApprovalUtils";

jest.autoMockOff();
jest.mock("axios", () => ({
  __esModule: true,
}));

jest.mock('../utils/store/store')



const mockState = {
  auth: { sessionUid: '12432sdsw32432' },
  stages:[],
  urlParam:{applicationDetails:{channelRefNo:'23432432432'}}
}

jest.mock("../modules/preApproval/services/preApprovalUtils", () => ({
  getFormConfigPayload: jest.fn(() => ({ applicants: {}, application: {} })),
  getAckMetaData:jest.fn(() => "mocked_meta_data"),
  
  //jest.fn(() => "mocked_meta_data"),
  getADFormConfigPayload: jest.fn(),
  generateUUID: jest.fn(),
}));

// jest.mock('../modules/preApproval/services/preApprovalUtils', () => {
//   getAckMetaData:jest.fn().mockResolvedValue(() => Promise.resolve());
// });

//jest.spyOn(PreApprovalUtil, 'getAckMetaData').mockResolvedValue( Promise.resolve("AckMetaData"));
// const mockedAxios = axios as jest.Mocked<typeof axios>;

jest.mock('axios', () => {
  return {
      interceptors: {
          request: { use: jest.fn(), eject: jest.fn(),headers:{set:jest.fn() }},
          response: { use: jest.fn(), eject: jest.fn() },
      },
  };
});




 let requestData={
  "transitional": {
    "silentJSONParsing": true,
    "forcedJSONParsing": true,
    "clarifyTimeoutError": false
  },
  "adapter": [
    "xhr",
    "http",
    "fetch"
  ],
  "transformRequest": [],
  "transformResponse": [],
  "timeout": 0,
  "xsrfCookieName": "XSRF-TOKEN",
  "xsrfHeaderName": "X-XSRF-TOKEN",
  "maxContentLength": -1,
  "maxBodyLength": -1,
  "env": {},
  "method": "get",
  "url": "/onboarding/hk-uat/api/v1/login",
  "target": "https://pt.sc.com",
  "changeOrigin": true,
  "secure": false,
 "headers": {
      "Accept": "application/json, text/plain, */*",
      "Authorization": "NTB LOGIN",
      "SC-CLIENT-CONTEXT": "{\"reqId\":\"a3763340-00c6-48fa-bc20-d3ff41636fba\",\"Channel\":\"MOBILE\",\"Country\":\"SG\",\"Language\":\"EN\",\"AppName\":\"RCWB\",\"ClientId\":\"MOBILE\",\"InstanceCode\":\"CB_IN\",\"RumDevice\":\"devicebrowserversion\",\"Source\":\"sc.com\",\"DeviceType\":\"Desktop\"}"
  },
}

describe("defaultInterceptor", () => {

  
  beforeEach(() => {
    jest.clearAllMocks();
    jest.mock('../utils/store/store');
    store.getState=jest.fn().mockReturnValue(mockState);

  })
 
  test("injectStore", () => {
    expect(undefined).toEqual(injectStore(store))
  })

  

  // test("setAbortController", () => {
  //  const timeout= setAbortTimeout();
  //   expect(timeout).toEqual(8);
  //  });

  //  test("setRequestHeader", () => {
  //  const header= setRequestHeader( JSON.parse(JSON.stringify(requestData)));

  //  header.then((res:any)=>{

  //   expect(res.headers['SC-CLIENT-CONTEXT']).toEqual(undefined);

  //  })
    
  //   });

    // test("setResponseTimeout", () => {
    //   const timeout= setResponseTimeout();
    //    expect(timeout).toEqual(undefined);
    //   });

    //   test("setResponseTimeout", () => {
    //     const response= setResponseTimeout();
    //      expect(response).toEqual(undefined);
    //     });

            
    //   test("setInterceptorsRequestHeader", () => {
    //     const response= setInterceptorsRequestHeader();
    //      expect(response).toEqual(undefined);
    //     });

  test("defaultInterceptor", () => {
   expect(undefined).toEqual(defaultInterceptor("EN"));
  });

  

});
