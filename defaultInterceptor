import axios from "axios";
import PreApprovalUtil from "../modules/preApproval/services/preApprovalUtils";
import submitService from "../services/submit-service";
import { CONSTANTS } from "../utils/common/constants";

let store: any;

export const injectStore = (_store: any) => {
  store = _store;
};

const defaultInterceptor = (lang: string | null) => {
  console.log('store'+JSON.stringify(store));
  let scClientContextHeaders: any = {
      Channel: "MOBILE",
      loginType: "PRE",
      Country: "HK",
      Language: "EN",
      AppName: "RCWB",
      ClientId: "MOBILE",
      InstanceCode: "CB_HK",
      RumDevice: "devicebrowserversion",
      Source: "sc.com",
      DeviceType: "MOBILE",
      subChannelCode: "",    
      sessionUID: store.getState().auth.sessionUid,
      BrowserAgent: "DESKTOP-BROWSER",
      IPAddress: ""
  };

  let abortController = new AbortController();
  const timeout = setTimeout(() => {
    abortController.abort();
  }, 180000);

  axios?.interceptors.request.use(
    async (request) => {
      let currentEndpoint: any = request.url && request.url.split("/");
      let uUid = submitService.generateUUID;
      let header: any = {
        "Content-Type": "application/json;charset=UTF-8",
      };

      scClientContextHeaders["reqId"] = uUid;
      let endPointURL = currentEndpoint[currentEndpoint.length - 1];
      if (store.getState().auth.sessionUid !== null) {
        const sessionUid = store.getState().auth.sessionUid;
        scClientContextHeaders["sessionUID"] = sessionUid;
      }
      header["Env"] = `${process.env.REACT_APP_RTOB_ENV}`;
      if (endPointURL === 'supportingaof') {
        header['responseType'] = 'arraybuffer';
      }
      
    let stages = JSON.parse(JSON.stringify(store.getState().stages));

      if(stages.stages && stages.stages.length > 0 && stages.stages[0].stageId && (stages.stages[0].stageId === CONSTANTS.STAGE_NAMES.AD_1 || stages.stages[0].stageId === CONSTANTS.STAGE_NAMES.ACD_1)) {
          request.headers["SC-CLIENT-CONTEXT"] = 
            await PreApprovalUtil.getAckMetaDataStageLevel(store.getState().urlParam.applicationDetails.channelRefNo)
      }
      else {
        request.headers["SC-CLIENT-CONTEXT"] = 
            PreApprovalUtil.getAckMetaData(store.getState().urlParam.applicationDetails.channelRefNo)
      }
      request.headers.set(header);

      return {
        ...request,
        signal: abortController.signal,
      };
    }
  );

  axios?.interceptors.response.use((res) => {
    clearTimeout(timeout);
    return res;
  });
};

export default defaultInterceptor;



import axios from "axios";
import MockAdapter from "axios-mock-adapter";
import defaultInterceptor, { injectStore } from "../path/to/defaultInterceptor";
import PreApprovalUtil from "../modules/preApproval/services/preApprovalUtils";
import submitService from "../services/submit-service";
import { CONSTANTS } from "../utils/common/constants";

jest.mock("../modules/preApproval/services/preApprovalUtils");
jest.mock("../services/submit-service");

describe("defaultInterceptor", () => {
  let mockStore: any;
  let mockAxios: MockAdapter;

  beforeEach(() => {
    // Mock store
    mockStore = {
      getState: jest.fn().mockReturnValue({
        auth: { sessionUid: "test-session-uid" },
        urlParam: { applicationDetails: { channelRefNo: "test-ref-no" } },
        stages: {
          stages: [
            {
              stageId: CONSTANTS.STAGE_NAMES.AD_1,
            },
          ],
        },
      }),
    };

    // Inject store
    injectStore(mockStore);

    // Mock axios
    mockAxios = new MockAdapter(axios);
  });

  afterEach(() => {
    jest.clearAllMocks();
    mockAxios.reset();
  });

  it("should set request headers correctly for AD_1 stage", async () => {
    const mockRequest = {
      url: "https://example.com/supportingaof",
      headers: new Map(),
    };

    // Mock PreApprovalUtil.getAckMetaDataStageLevel
    (PreApprovalUtil.getAckMetaDataStageLevel as jest.Mock).mockResolvedValue(
      "mocked-metadata"
    );

    const addInterceptor = () => defaultInterceptor("EN");
    addInterceptor();

    const onFulfilled = mockAxios.handlers.request[0][0];
    const modifiedRequest = await onFulfilled(mockRequest);

    expect(modifiedRequest.headers.get("SC-CLIENT-CONTEXT")).toEqual(
      "mocked-metadata"
    );
    expect(modifiedRequest.headers.get("responseType")).toBeUndefined();
    expect(modifiedRequest.signal).toBeDefined();
  });

  it("should set responseType to arraybuffer for supportingaof endpoint", async () => {
    const mockRequest = {
      url: "https://example.com/supportingaof",
      headers: new Map(),
    };

    const addInterceptor = () => defaultInterceptor("EN");
    addInterceptor();

    const onFulfilled = mockAxios.handlers.request[0][0];
    const modifiedRequest = await onFulfilled(mockRequest);

    expect(modifiedRequest.headers.get("responseType")).toEqual("arraybuffer");
  });

  it("should clear timeout on response", () => {
    const mockResponse = { data: { success: true } };

    const addInterceptor = () => defaultInterceptor("EN");
    addInterceptor();

    const onFulfilled = mockAxios.handlers.response[0][0];
    const modifiedResponse = onFulfilled(mockResponse);

    expect(modifiedResponse).toEqual(mockResponse);
  });

  it("should handle a missing session UID gracefully", async () => {
    mockStore.getState.mockReturnValueOnce({
      auth: { sessionUid: null },
      urlParam: { applicationDetails: { channelRefNo: "test-ref-no" } },
      stages: { stages: [] },
    });

    const mockRequest = {
      url: "https://example.com/endpoint",
      headers: new Map(),
    };

    const addInterceptor = () => defaultInterceptor("EN");
    addInterceptor();

    const onFulfilled = mockAxios.handlers.request[0][0];
    const modifiedRequest = await onFulfilled(mockRequest);

    expect(modifiedRequest.headers.get("SC-CLIENT-CONTEXT")).toBeUndefined();
  });

  it("should set SC-CLIENT-CONTEXT using PreApprovalUtil.getAckMetaData if stage is not AD_1 or ACD_1", async () => {
    mockStore.getState.mockReturnValueOnce({
      auth: { sessionUid: "test-session-uid" },
      urlParam: { applicationDetails: { channelRefNo: "test-ref-no" } },
      stages: {
        stages: [
          {
            stageId: "some-other-stage",
          },
        ],
      },
    });

    const mockRequest = {
      url: "https://example.com/endpoint",
      headers: new Map(),
    };

    (PreApprovalUtil.getAckMetaData as jest.Mock).mockReturnValue(
      "mocked-metadata"
    );

    const addInterceptor = () => defaultInterceptor("EN");
    addInterceptor();

    const onFulfilled = mockAxios.handlers.request[0][0];
    const modifiedRequest = await onFulfilled(mockRequest);

    expect(modifiedRequest.headers.get("SC-CLIENT-CONTEXT")).toEqual(
      "mocked-metadata"
    );
  });
});







import axios from "axios";
import MockAdapter from "axios-mock-adapter";
import defaultInterceptor, { injectStore } from "../path/to/defaultInterceptor";
import PreApprovalUtil from "../modules/preApproval/services/preApprovalUtils";
import submitService from "../services/submit-service";
import { CONSTANTS } from "../utils/common/constants";

jest.mock("../modules/preApproval/services/preApprovalUtils");
jest.mock("../services/submit-service");

describe("defaultInterceptor", () => {
  let mockStore: any;
  let mockAxios: MockAdapter;

  beforeEach(() => {
    // Mock store
    mockStore = {
      getState: jest.fn().mockReturnValue({
        auth: { sessionUid: "test-session-uid" },
        urlParam: { applicationDetails: { channelRefNo: "test-ref-no" } },
        stages: {
          stages: [
            {
              stageId: CONSTANTS.STAGE_NAMES.AD_1,
            },
          ],
        },
      }),
    };

    // Inject store
    injectStore(mockStore);

    // Mock axios
    mockAxios = new MockAdapter(axios);
  });

  afterEach(() => {
    jest.clearAllMocks();
    mockAxios.reset();
  });

  it("should set request headers correctly for AD_1 stage", async () => {
    // Configure mock response
    mockAxios.onAny().reply(200);

    const mockRequest = {
      url: "https://example.com/supportingaof",
      headers: {},
    };

    (PreApprovalUtil.getAckMetaDataStageLevel as jest.Mock).mockResolvedValue(
      "mocked-metadata"
    );

    defaultInterceptor("EN"); // Add interceptor

    const response = await axios.get(mockRequest.url);

    // Assertions
    expect(response.config.headers["SC-CLIENT-CONTEXT"]).toEqual(
      "mocked-metadata"
    );
  });

  it("should set responseType to arraybuffer for supportingaof endpoint", async () => {
    mockAxios.onAny().reply(200);

    defaultInterceptor("EN");

    const response = await axios.get("https://example.com/supportingaof");

    expect(response.config.headers["responseType"]).toEqual("arraybuffer");
  });

  it("should clear timeout on response", async () => {
    mockAxios.onAny().reply(200, { success: true });

    defaultInterceptor("EN");

    const response = await axios.get("https://example.com");

    expect(response.data.success).toBe(true);
  });
});
