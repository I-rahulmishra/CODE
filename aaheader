yimport { getProductMetaDataInfo } from './path-to-file';
import axios from 'axios';
import { PreApprovalUtil } from './PreApprovalUtil';
import { getUrl } from './getUrl';
import { urlParamAction } from './urlParamAction';
import { dispatchError } from './dispatchError';

jest.mock('axios');
jest.mock('./PreApprovalUtil', () => ({
  generateUUID: jest.fn(),
}));
jest.mock('./getUrl', () => ({
  getParameterByName: jest.fn(),
}));
jest.mock('./urlParamAction', () => ({
  productDetails: jest.fn(),
}));
jest.mock('./dispatchError', () => ({
  dispatchError: jest.fn(),
}));

const mockDispatch = jest.fn();

describe('getProductMetaDataInfo', () => {
  const mockUrlParams = {
    search: '?products=personal-loan&campaign=testCampaign&premium=testPremium',
  };

  const mockResponseData = {
    products: {
      personal: [
        { product_type: 'personal-loan', product_description: 'Test Description' },
      ],
    },
  };

  const mockFlatFilteredArray = [
    {
      campaign: 'testCampaign',
      name: 'personal-instalment-loan',
      company_category: 'NA',
      premiumCode: 'testPremium',
      product_type: 'personal-loan',
    },
  ];

  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('should fetch product metadata and dispatch product details if products are found', async () => {
    // Mock dependencies
    PreApprovalUtil.generateUUID.mockReturnValue('test-uuid');
    getUrl.getParameterByName.mockImplementation((param) => {
      switch (param) {
        case 'products':
          return 'personal-loan';
        case 'campaign':
          return 'testCampaign';
        case 'premium':
          return 'testPremium';
        default:
          return null;
      }
    });

    axios.request.mockResolvedValue({ data: mockResponseData });

    // Call the function
    const result = await getProductMetaDataInfo(mockUrlParams)(mockDispatch);

    // Assertions
    expect(axios.request).toHaveBeenCalledWith({
      method: 'GET',
      url: `${process.env.REACT_APP_PRODUCT_INFO_URL}`,
      headers: {
        Authorization: `${process.env.REACT_APP_RTOB_AUTHORIZATION}`,
        'SC-CLIENT-CONTEXT': expect.any(String),
      },
    });

    expect(urlParamAction.productDetails).toHaveBeenCalledWith(
      expect.arrayContaining([
        expect.objectContaining({ product_type: 'personal-loan' }),
      ])
    );

    expect(mockDispatch).toHaveBeenCalledWith(
      urlParamAction.productDetails(mockFlatFilteredArray)
    );

    expect(result).toEqual(mockFlatFilteredArray);
  });

  test('should handle no products in the response and dispatch an error', async () => {
    // Mock dependencies
    axios.request.mockResolvedValue({ data: { products: {} } });

    // Call the function
    await getProductMetaDataInfo(mockUrlParams)(mockDispatch);

    // Assertions
    expect(dispatchError).toHaveBeenCalledWith({
      response: {
        status: 'error',
        statusText: 'no response',
      },
    });
  });

  test('should handle axios request errors and dispatch an error', async () => {
    // Mock dependencies
    const mockError = new Error('Request failed');
    axios.request.mockRejectedValue(mockError);

    // Call the function
    await expect(
      getProductMetaDataInfo(mockUrlParams)(mockDispatch)
    ).rejects.toThrow('Request failed');

    // Assertions
    expect(dispatchError).toHaveBeenCalledWith(mockError);
    expect(mockDispatch).not.toHaveBeenCalledWith(
      urlParamAction.productDetails(expect.anything())
    );
  });

  test('should reject the promise if no "products" or "auth" parameter is found', async () => {
    // Mock dependencies
    getUrl.getParameterByName.mockReturnValue(null);

    // Call the function
    await expect(
      getProductMetaDataInfo(mockUrlParams)(mockDispatch)
    ).rejects.toBeUndefined();

    // Assertions
    expect(dispatchError).toHaveBeenCalledWith({
      response: {
        status: 'error',
        statusText: 'no response',
      },
    });
  });
});
